I"]<p>Letâ€™s start by finishing the videos on security.</p>

<p>Iâ€™ll have to install a module called validator for the email field and others.</p>

<p>Youâ€™ll need to define (justify this in the TMA/EMA) the minimum length of the password.</p>

<h3 id="jason-web-token">Jason Web Token</h3>

<p>Using material from TM352 you could justify this. The module is called jsonwebtoken</p>

<p>Two important methods, sign and verify. Youâ€™ll need video 89 to implement this. And:</p>

<ul>
  <li>Video 90 to undertsand how to implement it in the rest call. Plus the site for JWTs.</li>
  <li>Youâ€™ll need to create your own scheme (video 90) for this.</li>
</ul>

<p>You will need to justify the private routes (video 91). Remember UserSchema.statics for model methods. Minute 3:42 for this.</p>

<ul>
  <li>Video 92 is about hiding the passwords. The library is bcryptjs</li>
</ul>

<p>You need to explain what salting passwords isâ€¦once you learn it yourself. Bcryo genSalt method advantages to prevent brute force attack, use it.</p>

<p>Mongoose middleware will help hide the passwords.</p>

<p>Understanding the storage of passwords is one of the most complex things of the back-end of the web application because I havenâ€™t done it before.</p>

<ul>
  <li>Video 94 is the key because thatâ€™s the test case.</li>
  <li>Video 95 with findByCredentials to log in users by username and email (and get back the token)</li>
  <li><strong>Video 99 is the key of how to connect</strong> the data with the user who created it. Minute 4:12</li>
</ul>

<p>Right, so thatâ€™s all the videos I needed, now is time to start coding.</p>

<h3 id="the-coding-part">The coding part</h3>

<p>Following a method:</p>

<ol>
  <li>Create a folder for the project and a subfolder for the backend, run npm init to create a node project.</li>
  <li>Created an expressjs app that prints Hello.</li>
  <li>Created a test case with MOcha to test that hello. Put all the tests in a test folder</li>
  <li>Added the extra dev-dependencies iâ€™ll require (mocha, expect, supertest).</li>
  <li>Set nodemon index.js as the start routine.</li>
  <li>Wrote some test code</li>
</ol>

<p>And it works</p>

<p><img src="/uploads/2018/03/23/itowkrs.JPG" alt="" /></p>

<p>Now that Iâ€™ve got the basics of testing my app covered I need to develop all the other test cases but for that I need to model the data first.</p>

<p>On one side weâ€™ve got users. Users should be made of:</p>

<ul>
  <li>email</li>
  <li>password</li>
  <li>token</li>
</ul>

<p>For that I need mongoose. On the other side I need job applications, they should be made of, according to the mockup pictures of:</p>

<ul>
  <li>role_name</li>
  <li>company_name</li>
  <li>date_applied</li>
  <li>location</li>
  <li>reference __ later _ name_</li>
  <li>cv _ used _ name</li>
  <li>notes</li>
</ul>

<p>So before I create tests cases the model for this needs to be created in mongoose.</p>

<p>Right, I can create users, log them, unlog them.</p>

<h3 id="coding-the-users">Coding the users</h3>

<p>I needed to decide why to choose patch instead of put and I didnâ€™t get it but this link got it explained for me</p>

<p><a href="https://stackoverflow.com/questions/28459418/rest-api-put-vs-patch-with-real-life-examples" title="https://stackoverflow.com/questions/28459418/rest-api-put-vs-patch-with-real-life-examples">https://stackoverflow.com/questions/28459418/rest-api-put-vs-patch-with-real-life-examples</a></p>

<p>I only need to replace so patch is better than put in this case.</p>

<p>Well the code is there, is just a matter of doing some refactoring now.</p>

<p><img src="/uploads/2018/03/25/Capture.JPG" alt="" /></p>
:ET